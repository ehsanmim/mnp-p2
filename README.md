# mnp-p2
Modellierung nebenl√§ufiger Prozesse

Here is a structured to-do list and a plan for completing the project based on the provided pdf generated by AI. Feel free to improve the To-Dos.

We may do and mark them as done. Please also push any as soon as a small part is done so that we do have and complete each others work.

### **Phase 1: Project Setup and Initial Configuration**

This phase ensures the project environment is correctly configured according to the requirements.

* **To-Do:**
    * [ ] **Create a Gradle Project:** Set up a new Java project using the Gradle build tool. [cite: 13]
    * [ ] **Add Akka Dependency:** In the `build.gradle` file, add the `akka-actor-typed` library, ensuring the version is 2.9 or higher. [cite: 5]
    * [ ] **Define Project Structure:** Create a standard package structure (e.g., `de.meinautobauer.produktion`).
    * [ ] **Prepare File Headers:** Create a template for the file headers that includes placeholders for the names and matriculation numbers of all group members, to be used in all Java files. [cite: 9]

### **Phase 2: Designing the Core Actor and Message Protocol**

This phase focuses on the fundamental building blocks of the concurrent system: the actors and the messages they exchange.

* **To-Do:**
    * [ ] **Define Actor Messages:**
        * Create an immutable message class to instruct an actor to produce a component (e.g., `ProduceComponent`). This message must contain the name of the component to be built (e.g., "EB1") and a reference (`ActorRef`) to the parent actor that awaits the result.
        * Create a message to signal completion (e.g., `ComponentFinished`). This will be sent from a child actor back to its parent.
    * [ ] **Design the Production Actor:**
        * This will be the single, general-purpose actor responsible for producing any given component.
        * The actor's state will need to track which component it is building, who its parent is, and what step of its two-part blueprint it is on.
    * [ ] **Store Blueprints:** Create a data structure (e.g., a `Map`) to store the component blueprints within the application so they are easily accessible. [cite: 32]
        * $EB_1 = (BB_1, BB_2)$ [cite: 20]
        * $EB_2 = (EB_1, BB_2)$ [cite: 20]
        * $EB_3 = (BB_3, EB_2)$ [cite: 20]
        * $EB_4 = (EB_1, EB_3)$ [cite: 20]

### **Phase 3: Implementation of Production Logic**

This phase involves writing the Java code to bring the design to life, focusing on the parallel but ordered production flow.

* **To-Do:**
    * [ ] **Implement the Main Actor Logic:**
        * When the actor receives a `ProduceComponent` message, it checks if the component is a Basic Component (`BB`) or an Electronic Component (`EB`).
        * **If `BB`:** Log the production of the basic component and immediately send the `ComponentFinished` message to the parent. [cite: 33]
        * **If `EB`:**
            1.  Look up the two sub-components from the blueprint map.
            2.  Spawn a new anonymous actor for the *first* sub-component using `context.spawnAnonymous()`. [cite: 37]
            3.  Send a `ProduceComponent` message to this new child actor.
            4.  The actor must now wait. Implement the logic to handle the `ComponentFinished` message from the first child.
            5.  Upon receiving `ComponentFinished` from the first child, spawn another anonymous actor for the *second* sub-component. [cite: 30]
            6.  Send a `ProduceComponent` message to the second child.
            7.  Upon receiving `ComponentFinished` from the second child, the `EB` itself is considered complete. Log its completion and send `ComponentFinished` to its own parent. [cite: 25, 33]
    * [ ] **Create the Main Application Class:**
        * Set up and start the Akka `ActorSystem`.
        * Create an initial actor to kick off the entire production process.
        * This actor will send the first `ProduceComponent` message to start the production of $EB_4$, as required for the test. [cite: 26]

### **Phase 4: Testing and Creation of a New Component**

This phase is for verifying the correctness of the implementation and fulfilling the final task requirements.

* **To-Do:**
    * [ ] **Test `EB_4` Production:** Run the application and carefully examine the console output. Verify that the production sequence respects the dependencies and order outlined in the blueprints. [cite: 24, 34] Ensure the logs clearly show which components are being built. [cite: 25]
    * [ ] **Define and Implement a New Component:**
        * Design a new electronic component, let's call it $EB_5$, that has a dependency tree with a depth of at least three. [cite: 27] A simple valid example would be $EB_5 = (EB_3, EB_4)$.
        * Add this new blueprint to your data structure.
    * [ ] **Test New Component Production:** Modify the main application to trigger the production of your new component ($EB_5$) and verify its output.

### **Phase 5: Final Review and Submission**

The final step is to polish the project and prepare it for submission.

* **To-Do:**
    * [ ] **Add Code Comments:** Review all code and add meaningful comments to explain the logic, especially the actor's behavior and message handling.
    * [ ] **Finalize Headers:** Fill in the names and matriculation numbers of all group members in the header of every Java file. [cite: 9]
    * [ ] **Check for Prohibited Libraries/Methods:** Ensure that the project only uses the Akka Typed library and the Java standard library, with no dependencies on Classic Akka. [cite: 6, 7]
    * [ ] **Create Submission Archive:** Compile the project and then package the entire Gradle project folder into a single `.zip` file. [cite: 13]
    * [ ] **Submit:** Upload the `.zip` file to Moodle before the deadline of **July 6, 2025, 23:59**. [cite: 3]